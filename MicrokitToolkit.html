<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Microkit Toolkit</title>
  <style>
    :root {
      /* Light theme (defaults) */
      --bg: #f9f9f9;
      --panel: #ffffff;
      --muted: #666666;
      --text: #222222;
      --muted-border: #dddddd;
      --cell-off: #e0e0e0;
      --cell-on: #489e73;
      --control-bg: #F9F9F9;
      --control-border: rgba(0, 0, 0, 0.08);
      --accent: #489e73;
      --overlay-bg: rgba(0, 0, 0, 0.5);
      --card-shadow: rgba(0, 0, 0, 0.12);
    }

    /* Dark theme overrides (toggle by adding .dark-mode to body) */
    .dark-mode {
      --bg: #1b1b1b;
      --panel: #2b2b2b;
      --muted: #bdbdbd;
      --text: #e8e8e8;
      --muted-border: #444444;
      --cell-off: #1f1f1f;
      --cell-on: #3b8a62;
      --control-bg: #333333;
      --control-border: #444444;
      --accent: #3b8a62;
      --overlay-bg: rgba(0, 0, 0, 0.6);
      --card-shadow: rgba(0, 0, 0, 0.36);
    }

    /* ===== Base layout ===== */
    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition: background-color 180ms ease, color 180ms ease;
    }

    /* Container columns */
    .container {
      display: flex;
      gap: 18px;
      align-items: flex-start;
      padding: 18px;
      width: 1100px;
      box-sizing: border-box;
    }

    /* Left column (main) */
    .main {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 640px;
    }

    /* Title */
    .title {
      text-align: center;
      margin-bottom: 6px;
    }

    .title h4 {
      margin: 0;
    }

    .title h5 {
      margin: 0;
      font-weight: 400;
      color: var(--muted);
    }

    /* ===== Matrix grid ===== */
    .grid {
      display: grid;
      grid-template-columns: repeat(8, 30px);
      grid-template-rows: repeat(8, 30px);
      gap: 4px;
      margin-bottom: 10px;
      background: transparent;
      touch-action: none;
    }

    .cell {
      width: 30px;
      height: 30px;
      background-color: var(--cell-off);
      border-radius: 250px;
      transition: background-color 30ms linear, transform 80ms ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      display: inline-block;
    }

    .cell.on {
      background-color: var(--cell-on);
    }

    .cell:active {
      transform: scale(0.98);
    }

    .cell:hover {
      cursor: pointer;
    }

    /* Hex inputs under grid */
    .inputs {
      display: grid;
      grid-template-columns: repeat(8, 30px);
      gap: 4px;
      margin-bottom: 8px;
      align-items: center;
      justify-items: center;
    }

    .inputs input {
      width: 24px;
      height: 24px;
      text-align: center;
      font-size: 12px;
      border: 1px solid var(--muted-border);
      border-radius: 4px;
      background-color: var(--panel);
      color: var(--text);
    }

    /* ===== Controls row ===== */
    .controls-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      width: 100%;
      justify-content: center;
    }

    .controls-left {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .controls-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Buttons */
    .btn {
      border: 1px solid var(--control-border);
      border-radius: 100px;
      padding: 8px 14px;
      background-color: var(--control-bg);
      color: var(--text);
      transition: opacity 140ms ease, background-color 140ms ease, border-color 140ms ease;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }

    .btn:hover {
      opacity: 0.9;
    }

    .small {
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 12px;
    }

    /* Arrow visual */
    .arrow-wrapper {
      display: flex;
      align-items: center;
      margin-top: 10px;
      margin-left: -5px;
    }

    .arrow-head-left {
      width: 0;
      height: 0;
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      border-right: 20px solid var(--accent);
    }

    .arrow-line {
      width: calc(8 * 30px + 7 * 4px - 20px);
      height: 4px;
      background-color: var(--accent);
    }

    /* Jump calc */
    .jump-calc {
      margin-top: 12px;
      text-align: left;
      font-size: 14px;
      width: 100%;
      color: var(--muted);
    }

    .jump-calc input {
      width: 80px;
      margin: 0 10px 0 6px;
    }

    /* ===== Timeline panel ===== */
    .timeline-panel {
      width: 480px;
      background: var(--panel);
      border: 1px solid var(--muted-border);
      border-radius: 8px;
      padding: 12px;
      box-sizing: border-box;
      height: 640px;
      overflow: auto;
      color: var(--text);
      transition: background-color 180ms ease, border-color 180ms ease, color 180ms ease;
    }

    .timeline-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .frame-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Timeline item layout */
    .frame {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 12px;
      padding: 8px;
      border: 1px dashed var(--muted-border);
      border-radius: 8px;
      background: linear-gradient(transparent, transparent);
      color: var(--text);
    }

    .frame-left {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-start;
      flex: 0 0 auto;
    }

    .frame-name {
      font-weight: 600;
      font-size: 13px;
      color: var(--text);
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 120px;
    }

    /* Mini preview */
    .mini-preview {
      display: grid;
      grid-template-columns: repeat(8, 10px);
      grid-template-rows: repeat(8, 10px);
      gap: 2px;
      width: calc(9 * 10px + 6 * 2px);
      height: calc(9 * 10px + 6 * 2px);
      border-radius: 3px;
      overflow: hidden;
      background: var(--panel);
      padding: 4px;
      box-sizing: border-box;
      cursor: pointer;
    }

    .mini-preview .dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
      background: var(--cell-off);
      transition: background 120ms linear;
    }

    .mini-preview .dot.on {
      background: var(--cell-on);
    }

    /* Actions on the right */
    .frame-actions {
      display: flex;
      flex-direction: row;
      gap: 6px;
      margin-left: auto;
      align-items: flex-end;
      flex: 0 0 auto;
    }

    .frame-actions .row {
      display: flex;
      gap: 6px;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .tab {
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid var(--muted-border);
      background: var(--panel);
      color: var(--text);
    }

    .tab.active {
      background: var(--accent);
      color: #fff;
      border-color: color-mix(in srgb, var(--accent) 60%, var(--muted-border));
    }

    /* Dark-mode small overrides */
    .dark-mode .inputs input {
      background: var(--panel);
      color: var(--text);
      border-color: var(--muted-border);
    }

    .dark-mode .btn {
      background: var(--control-bg);
      color: var(--text);
      border-color: var(--control-border);
    }

    /* ===== Overlay / preview modal ===== */
    .overlay {
      position: fixed;
      inset: 0;
      background: var(--overlay-bg);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .overlay.show {
      display: flex;
    }

    .preview-card {
      background: var(--panel);
      padding: 14px;
      border-radius: 8px;
      box-shadow: 0 6px 20px var(--card-shadow);
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      text-align: center;
      color: var(--text);
    }

    .preview-grid {
      display: grid;
      grid-template-columns: repeat(8, 30px);
      grid-template-rows: repeat(8, 30px);
      gap: 6px;
      margin: 12px auto;
    }

    .preview-grid .cell {
      width: 30px;
      height: 30px;
      border-radius: 4px;
      background: var(--cell-off);
    }

    .preview-grid .cell.on {
      background: var(--cell-on);
    }

    /* Small helpers */
    .frame-note,
    .jump-calc span,
    .title h5 {
      color: var(--muted);
    }

    /* Responsive */
    @media (max-width: 1150px) {
      .container {
        width: 100%;
        padding: 8px;
        flex-direction: column;
        align-items: stretch;
      }

      .main {
        width: auto;
      }

      .timeline-panel {
        width: 100%;
        height: 360px;
      }
    }

    /* drag visual feedback for frames */
    .frame.dragging {
      opacity: 0.45;
      border-style: solid;
      border-color: color-mix(in srgb, var(--accent) 70%, transparent);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
    }

    /* subtle focus styles for keyboard navigation */
    .btn:focus,
    .copy-btn:focus,
    .tab:focus {
      outline: 3px solid color-mix(in srgb, var(--accent) 18%, transparent);
      outline-offset: 2px;
    }

    /* utility: visually-hidden for accessible labels */
    .visually-hidden {
      position: absolute !important;
      height: 1px;
      width: 1px;
      overflow: hidden;
      clip: rect(1px, 1px, 1px, 1px);
      white-space: nowrap;
    }

    /* small helper for muted pills */
    .pill-muted {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.03);
      color: var(--muted);
      font-size: 12px;
    }

    /* keep transitions on color changes smooth for preview dots */
    .mini-preview .dot,
    .preview-grid .cell {
      transition: background-color 120ms linear, transform 80ms ease;
    }
  </style>
</head>

<body onload="start()">
  <div class="container">
    <div class="main">
      <div class="title">
        <h4 style="margin:0;">8√ó8 Matrix to Hexadecimal :)</h4>
        <h5 style="margin:0; font-weight:normal;">For micropro</h5>
        <br>
      </div>

      <div class="grid" id="grid" aria-label="8 by 8 LED matrix"></div>
      <div class="inputs" id="inputs"></div>

      <div class="arrow-wrapper" style="margin-bottom:10px;">
        <div class="arrow-head-left"
          style="width:0;height:0;border-top:10px solid transparent;border-bottom:10px solid transparent;border-right:20px solid var(--accent);">
        </div>
        <div class="arrow-line"
          style="width:calc(8 * 30px + 7 * 4px - 20px);height:4px;background-color:var(--accent);"></div>
      </div>

      <div class="controls-row">
        <div class="controls-left">
          <button class="btn" onclick="resetGrid()">Reset</button>
          <button class="btn" id="addFrameBtn" onclick="showAddFrame()">Add to timeline</button>
          <!-- Fill controls -->
          <label style="display:flex;align-items:center;gap:6px;margin-left:8px;">
            <select id="fillColorSelect" class="btn small" style="padding:6px;border-radius:6px;">
              <!-- options populated by JS -->
            </select>
            <button class="btn small" onclick="fillGrid()">Fill</button>
          </label>
        </div>

        <div class="controls-right">
          <label style="display:flex;align-items:center;">
            <input id="toggle" type="checkbox" style="display:none;" aria-hidden="true">
            <button id="themeBtn" class="btn" aria-pressed="false" title="Toggle theme">
              <span id="themeIcon"
                style="display:inline-block;width:18px;height:18px;line-height:18px;font-size:14px;">üåô</span>
            </button>
          </label>

        </div>
      </div>

      <div id="addFrameControls" style="display:none; align-items:center; gap:6px;">
        <input id="frameName" placeholder="Frame name" style="padding:6px;border-radius:6px;border:1px solid #ccc;">
        <button class="btn small" onclick="addOrOverwriteFrame()">Save</button>
        <button class="btn small" onclick="hideAddFrame()">Cancel</button>
      </div>

      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:8px;">
        <button class="btn small" onclick="shiftLeft()">
          ‚Üê Shift Left</button>
        <button class="btn small" onclick="shiftRight()">
          ‚Üí Shift Right</button>
        <button class="btn small" onclick="shiftUp()">
          ‚Üë Shift Up</button>
        <button class="btn small" onclick="shiftDown()">
          ‚Üì Shift Down</button>
      </div>
      <br>
      <div class="jump-calc" style="margin-top:12px;text-align:left;font-size:14px;width:100%;color:var(--muted);">
        <h4 style="margin:6px 0;">Jump/Loop Offset Calculator</h4>
        <label>Current Address: <input type="text" id="current" value="1000"></label>
        <label style="margin-left:12px;">Target Address: <input type="text" id="target" value="1000"></label>
        <button class="btn" style="margin-left:10px;" onclick="calculateJump()">Calculate</button>
        <p id="result" style="margin-top:8px;"></p>
      </div>
      <div style="font-style: italic; font-size: 15px; margin-top: 20px; opacity: 60%;">
        Update: Added Undo/Redo, Frame drag reordering, Frame Updating, Grid Fill, improved offset calculation, and UI
        improvements.
      </div>
    </div>

    <div class="timeline-panel" id="timelinePanel" aria-label="Timeline and animation controls">
      <div class="timeline-header">
        <div style="display:flex;flex-direction:column;">
          <strong>Timeline</strong>
          <span style="font-size:12px;color:#666;">Frames you saved from the matrix</span>
        </div>
        <div style="display:flex;gap:8px;align-items:center;">
          <div class="tabs">
            <div class="tab active" id="tabFrames" onclick="switchTab('frames')">Frames</div>
            <div class="tab" id="tabPlayer" onclick="switchTab('player')">Player</div>
          </div>
        </div>
      </div>

      <div id="framesTab">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
          <button class="btn small" onclick="clearTimeline()">Clear timeline</button>
          <button class="btn small" onclick="duplicateSelected()">Duplicate last</button>
          <span style="margin-left:auto;font-size:12px;color:#666;" id="frameCount">0 frames</span>
        </div>
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
          <button class="btn small" id="saveLocalBtn">Save locally</button>
          <button class="btn small" id="loadLocalBtn">Load local</button>
          <button class="btn small" id="exportBtn">Export JSON</button>
          <label class="btn small" style="cursor:pointer;">
            Import JSON
            <input id="importFile" type="file" accept="application/json" style="display:none;">
          </label>
        </div>
        <div class="frame-list" id="frameList"></div>
      </div>

      <div id="playerTab" style="display:none;">
        <div style="display:flex;flex-direction:column;gap:8px;">
          <div style="display:flex;gap:8px;align-items:center;">
            <button class="btn" id="playBtn" onclick="togglePlay()">Play</button>
            <button class="btn" onclick="stopTimeline()">Stop</button>
            <label style="display:flex;align-items:center;gap:8px;">
              <input type="checkbox" id="loopToggle"> Loop
            </label>
            <label style="display:flex;align-items:center;gap:8px;margin-left:auto;">
              Frame duration:
              <input type="range" id="speedRange" min="50" max="2000" value="300" oninput="speedChanged()">
            </label>
          </div>

          <div style="display:flex;gap:8px;align-items:center;">
            <div style="font-size:13px;">Speed: <span id="speedLabel">300</span> ms</div>
            <div style="margin-left:auto;">
              <button class="btn small" onclick="stepBackward()">‚óÄ</button>
              <button class="btn small" onclick="stepForward()">‚ñ∂</button>
              <span style="margin-left:8px;font-size:13px;">Current: <span id="currentFrameIndex">-</span></span>
            </div>
          </div>

          <div class="note">Use Frames tab to add, rename, reorder, or remove frames. Player uses the current timeline
            order for animation.</div>
        </div>
      </div>

    </div>
  </div>
  <!-- Overlay modal for expanded preview -->
  <div class="overlay" id="overlay">
    <div class="preview-card" id="previewCard">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <strong id="previewTitle">Frame Preview</strong>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn small" onclick="closePreview()">Close</button>
        </div>
      </div>
      <span id="previewHex" style="font-family:monospace;"></span>
      <div class="preview-grid" id="previewGrid"></div>
      <div style="margin-top:8px;">
        <button class="btn" onclick="applyPreviewToGrid()">Apply to grid</button>
      </div>
    </div>
  </div>

  <script>
    /* --- DOM references --- */
    const grid = document.getElementById('grid');
    const inputs = document.getElementById('inputs');
    const cells = [];
    let timeline = [];
    let playing = false;
    let playTimer = null;
    let playIndex = 0;

    /* --- Colors --- */
    const CELL_COLORS = [null, '#489e73', '#e94f4f', '#f4a300', '#f7e13d'];

    /* --- History (undo/redo) --- */
    const HISTORY_LIMIT = 60;
    let historyStack = [];
    let historyIndex = -1;
    let isApplyingHistory = false;

    function snapshotState() {
      const gridBits = cells.map(c => c.classList.contains('on'));
      const gridColors = cells.map(c => c.getAttribute('data-color') || null);
      const tl = timeline.map(f => ({ name: f.name, hex: Array.from(f.hex || []), bits: Array.from(f.bits || []), colors: Array.from(f.colors || []) }));
      return { gridBits, gridColors, timeline: tl };
    }

    function applyHistorySnapshot(snap) {
      if (!snap) return;
      for (let i = 0; i < cells.length; i++) {
        const on = !!snap.gridBits[i];
        cells[i].classList.toggle('on', on);
        const col = snap.gridColors[i];
        if (col) { cells[i].setAttribute('data-color', col); cells[i].style.backgroundColor = on ? col : ''; }
        else { cells[i].removeAttribute('data-color'); cells[i].style.backgroundColor = ''; }
      }
      timeline = snap.timeline.map(f => normalizeFrame(f));
      renderTimeline();
      updateHex();
      updatePlayerStateDisplay();
    }

    function pushHistory(actionLabel = '') {
      if (isApplyingHistory) return;
      const snap = snapshotState();
      historyStack = historyStack.slice(0, historyIndex + 1);
      historyStack.push({ snap, label: actionLabel, ts: Date.now() });
      if (historyStack.length > HISTORY_LIMIT) historyStack.shift();
      historyIndex = historyStack.length - 1;
    }

    function undo() {
      if (historyIndex <= 0) return;
      historyIndex--;
      const item = historyStack[historyIndex];
      isApplyingHistory = true;
      applyHistorySnapshot(item.snap);
      isApplyingHistory = false;
    }

    function redo() {
      if (historyIndex >= historyStack.length - 1) return;
      historyIndex++;
      const item = historyStack[historyIndex];
      isApplyingHistory = true;
      applyHistorySnapshot(item.snap);
      isApplyingHistory = false;
    }

    /* --- Utilities --- */
    function getColorIndex(hex) {
      if (!hex) return 0;
      hex = hex.toUpperCase();
      for (let i = 1; i < CELL_COLORS.length; i++) if (CELL_COLORS[i].toUpperCase() === hex) return i;
      return 0;
    }
    function applyColorIndexToCell(cell, idx) {
      const color = CELL_COLORS[idx] || null;
      if (!color) {
        cell.removeAttribute('data-color');
        cell.classList.remove('on');
        cell.style.backgroundColor = '';
      } else {
        cell.setAttribute('data-color', color);
        cell.classList.add('on');
        cell.style.backgroundColor = color;
      }
    }
    function cycleCellColor(cell) {
      const cur = cell.getAttribute('data-color');
      let idx = getColorIndex(cur);
      idx = (idx + 1) % CELL_COLORS.length;
      applyColorIndexToCell(cell, idx);
    }

    /* --- Grid creation & hex UI --- */
    function createGrid() {
      grid.innerHTML = '';
      cells.length = 0;
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          cell.dataset.row = row;
          cell.dataset.col = col;
          cell.addEventListener('click', () => {
            cycleCellColor(cell);
            updateHex();
            pushHistory('paint cell');
          });
          cell.style.touchAction = 'manipulation';
          grid.appendChild(cell);
          cells.push(cell);
        }
      }
    }

    function createHexInputs() {
      inputs.innerHTML = '';
      for (let i = 0; i < 8; i++) {
        const input = document.createElement('input');
        input.readOnly = true;
        inputs.appendChild(input);
      }
    }

    function updateHex() {
      const inputElems = inputs.querySelectorAll('input');
      for (let col = 0; col < 8; col++) {
        let binary = '';
        for (let row = 0; row < 8; row++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          binary += cell.classList.contains('on') ? '0' : '1';
        }
        const hex = parseInt(binary, 2).toString(16).padStart(2, '0').toUpperCase();
        inputElems[col].value = hex;
      }
    }

    /* --- Frame capture / apply --- */
    function captureCurrentFrame() {
      const hexes = [];
      const bits = [];
      const colors = [];
      for (let col = 0; col < 8; col++) {
        let binary = '';
        for (let row = 0; row < 8; row++) {
          const c = cells.find(x => +x.dataset.row === row && +x.dataset.col === col);
          const isOn = c.classList.contains('on');
          const bitForHex = isOn ? 0 : 1;
          binary += bitForHex.toString();
          bits.push(isOn);
          const colAttr = c.getAttribute('data-color');
          colors.push(colAttr ? colAttr.toUpperCase() : null);
        }
        hexes.push(parseInt(binary, 2).toString(16).padStart(2, '0').toUpperCase());
      }
      return { hexes, bits, colors };
    }

    function applyFrame(idx) {
      const f = timeline[idx];
      if (!f) return;
      for (let col = 0; col < 8; col++) {
        for (let row = 0; row < 8; row++) {
          const bitIndex = col * 8 + row;
          const c = cells.find(x => +x.dataset.row === row && +x.dataset.col === col);
          if (f.bits && f.bits[bitIndex]) c.classList.add('on'); else c.classList.remove('on');
          const colVal = f.colors && f.colors[bitIndex] ? f.colors[bitIndex] : null;
          if (colVal) {
            c.setAttribute('data-color', colVal);
            if (c.classList.contains('on')) c.style.backgroundColor = colVal; else c.style.backgroundColor = '';
          } else {
            c.removeAttribute('data-color');
            c.style.backgroundColor = '';
          }
        }
      }
      updateHex();
      pushHistory('apply frame');
    }

    /* --- Shifts and fill --- */
    function fillGrid() {
      const sel = document.getElementById('fillColorSelect');
      const val = sel.value || null;
      cells.forEach(c => {
        if (!val) {
          c.removeAttribute('data-color');
          c.classList.remove('on');
          c.style.backgroundColor = '';
        } else {
          c.setAttribute('data-color', val.toUpperCase());
          c.classList.add('on');
          c.style.backgroundColor = val.toUpperCase();
        }
      });
      updateHex();
      pushHistory('fill');
    }
    function resetGrid() {
      cells.forEach(c => { c.classList.remove('on'); c.removeAttribute('data-color'); c.style.backgroundColor = ''; });
      updateHex();
      pushHistory('reset grid');
    }
    function shiftLeft() {
      for (let row = 0; row < 8; row++) {
        const rowBits = []; const rowColors = [];
        for (let col = 0; col < 8; col++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          rowBits.push(cell.classList.contains('on'));
          rowColors.push(cell.getAttribute('data-color') || null);
        }
        rowBits.push(rowBits.shift()); rowColors.push(rowColors.shift());
        for (let col = 0; col < 8; col++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          cell.classList.toggle('on', rowBits[col]);
          const color = rowColors[col];
          if (color) { cell.setAttribute('data-color', color); cell.style.backgroundColor = rowBits[col] ? color : ''; }
          else { cell.removeAttribute('data-color'); cell.style.backgroundColor = ''; }
        }
      }
      updateHex();
      pushHistory('shift left');
    }
    function shiftRight() {
      for (let row = 0; row < 8; row++) {
        const rowBits = []; const rowColors = [];
        for (let col = 0; col < 8; col++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          rowBits.push(cell.classList.contains('on'));
          rowColors.push(cell.getAttribute('data-color') || null);
        }
        rowBits.unshift(rowBits.pop()); rowColors.unshift(rowColors.pop());
        for (let col = 0; col < 8; col++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          cell.classList.toggle('on', rowBits[col]);
          const color = rowColors[col];
          if (color) { cell.setAttribute('data-color', color); cell.style.backgroundColor = rowBits[col] ? color : ''; }
          else { cell.removeAttribute('data-color'); cell.style.backgroundColor = ''; }
        }
      }
      updateHex();
      pushHistory('shift right');
    }
    function shiftUp() {
      for (let col = 0; col < 8; col++) {
        const colBits = []; const colColors = [];
        for (let row = 0; row < 8; row++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          colBits.push(cell.classList.contains('on'));
          colColors.push(cell.getAttribute('data-color') || null);
        }
        colBits.push(colBits.shift()); colColors.push(colColors.shift());
        for (let row = 0; row < 8; row++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          cell.classList.toggle('on', colBits[row]);
          const color = colColors[row];
          if (color) { cell.setAttribute('data-color', color); cell.style.backgroundColor = colBits[row] ? color : ''; }
          else { cell.removeAttribute('data-color'); cell.style.backgroundColor = ''; }
        }
      }
      updateHex();
      pushHistory('shift up');
    }
    function shiftDown() {
      for (let col = 0; col < 8; col++) {
        const colBits = []; const colColors = [];
        for (let row = 0; row < 8; row++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          colBits.push(cell.classList.contains('on'));
          colColors.push(cell.getAttribute('data-color') || null);
        }
        colBits.unshift(colBits.pop()); colColors.unshift(colColors.pop());
        for (let row = 0; row < 8; row++) {
          const cell = cells.find(c => +c.dataset.row === row && +c.dataset.col === col);
          cell.classList.toggle('on', colBits[row]);
          const color = colColors[row];
          if (color) { cell.setAttribute('data-color', color); cell.style.backgroundColor = colBits[row] ? color : ''; }
          else { cell.removeAttribute('data-color'); cell.style.backgroundColor = ''; }
        }
      }
      updateHex();
      pushHistory('shift down');
    }

    /* --- Timeline drag helpers and rendering --- */
    const frameListElem = document.getElementById('frameList');
    const frameCountElem = document.getElementById('frameCount');

    let dragIndex = -1;
    let insertMarker = null;

    function createInsertMarker() {
      if (insertMarker) return;
      insertMarker = document.createElement('div');
      insertMarker.style.height = '2px';
      insertMarker.style.background = 'var(--accent)';
      insertMarker.style.position = 'relative';
      insertMarker.style.margin = '4px 0';
      insertMarker.style.borderRadius = '2px';
      insertMarker.className = 'insert-marker';
    }

    function enableDragOnFrame(frameDiv, idx) {
      frameDiv.setAttribute('draggable', 'true');
      frameDiv.addEventListener('dragstart', (e) => {
        dragIndex = idx;
        frameDiv.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain', String(idx)); } catch { }
        createInsertMarker();
      });
      frameDiv.addEventListener('dragend', () => {
        dragIndex = -1;
        frameDiv.classList.remove('dragging');
        removeInsertMarkers();
      });

      frameDiv.addEventListener('dragover', (e) => {
        e.preventDefault();
        const rect = frameDiv.getBoundingClientRect();
        const mid = rect.top + rect.height / 2;
        removeInsertMarkers();
        if (e.clientY < mid) {
          frameListElem.insertBefore(insertMarker, frameDiv);
          insertMarker.dataset.target = frameDiv.dataset.index;
          insertMarker.dataset.before = '1';
        } else {
          if (frameDiv.nextSibling) frameListElem.insertBefore(insertMarker, frameDiv.nextSibling);
          else frameListElem.appendChild(insertMarker);
          insertMarker.dataset.target = frameDiv.dataset.index;
          insertMarker.dataset.before = '0';
        }
      });

      frameDiv.addEventListener('drop', (e) => {
        e.preventDefault();
        const source = dragIndex >= 0 ? dragIndex : parseInt(e.dataTransfer.getData('text/plain') || '-1', 10);
        let target = parseInt(frameDiv.dataset.index, 10);
        if (insertMarker && insertMarker.parentNode === frameListElem) {
          const before = insertMarker.dataset.before === '1';
          if (!before) target = target + 1;
        }
        removeInsertMarkers();
        if (source >= 0 && target >= 0) {
          const item = timeline.splice(source, 1)[0];
          const adjustedTarget = source < target ? target - 1 : target;
          timeline.splice(adjustedTarget, 0, item);
          renderTimeline();
          pushHistory('move frame');
        }
      });
    }

    function removeInsertMarkers() {
      if (!insertMarker) return;
      if (insertMarker.parentNode) insertMarker.parentNode.removeChild(insertMarker);
    }

    function normalizeFrame(f) {
      f = Object.assign({}, f);
      f.hex = Array.isArray(f.hex) && f.hex.length === 8 ? f.hex : new Array(8).fill('00');
      f.bits = Array.isArray(f.bits) && f.bits.length === 64 ? f.bits : new Array(64).fill(false);
      if (!Array.isArray(f.colors) || f.colors.length !== 64) f.colors = new Array(64).fill(null);
      else f.colors = f.colors.map(c => c ? ('' + c).toUpperCase() : null);
      return f;
    }

    function showAddFrame() { document.getElementById('addFrameControls').style.display = 'flex'; document.getElementById('frameName').focus(); }
    function hideAddFrame() { document.getElementById('addFrameControls').style.display = 'none'; document.getElementById('frameName').value = ''; }

    function addToTimeline() {
      const nameInput = document.getElementById('frameName');
      const name = (nameInput.value || `Frame ${timeline.length + 1}`).trim();
      const captured = captureCurrentFrame();
      timeline.push({ name, hex: captured.hexes, bits: captured.bits, colors: captured.colors });
      nameInput.value = '';
      hideAddFrame();
      renderTimeline();
      pushHistory('add frame');
    }

    function renderTimeline() {
      frameListElem.innerHTML = '';
      timeline.forEach((f, idx) => {
        const frameDiv = document.createElement('div');
        frameDiv.className = 'frame';
        frameDiv.dataset.index = idx;

        const left = document.createElement('div');
        left.className = 'frame-left';

        const nameDiv = document.createElement('div');
        nameDiv.className = 'frame-name';
        nameDiv.textContent = f.name;

        const preview = document.createElement('div');
        preview.className = 'mini-preview';
        preview.title = 'Click to expand preview';
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const dot = document.createElement('div');
            dot.className = 'dot';
            const bitIndex = col * 8 + row;
            if (f.bits && f.bits[bitIndex]) dot.classList.add('on');
            if (f.colors && f.colors[bitIndex]) dot.style.backgroundColor = f.colors[bitIndex];
            preview.appendChild(dot);
          }
        }
        preview.onclick = () => openPreview(idx);

        left.appendChild(nameDiv);
        left.appendChild(preview);

        const actions = document.createElement('div');
        actions.className = 'frame-actions';

        const row1 = document.createElement('div'); row1.className = 'row';
        const applyBtn = document.createElement('button'); applyBtn.className = 'btn small'; applyBtn.textContent = 'Apply'; applyBtn.onclick = () => { applyFrame(idx); };
        const renameBtn = document.createElement('button'); renameBtn.className = 'btn small'; renameBtn.textContent = 'Rename'; renameBtn.onclick = () => renameFrame(idx);
        row1.appendChild(applyBtn); row1.appendChild(renameBtn);

        const row2 = document.createElement('div'); row2.className = 'row';
        const upBtn = document.createElement('button'); upBtn.className = 'btn small'; upBtn.textContent = '\u25b2'; upBtn.title = 'Move up'; upBtn.onclick = () => { moveFrameUp(idx); pushHistory('move up'); };
        const downBtn = document.createElement('button'); downBtn.className = 'btn small'; downBtn.textContent = '\u25bc'; downBtn.title = 'Move down'; downBtn.onclick = () => { moveFrameDown(idx); pushHistory('move down'); };
        const delBtn = document.createElement('button'); delBtn.className = 'btn small'; delBtn.textContent = 'Delete'; delBtn.onclick = () => { removeFrame(idx); pushHistory('delete frame'); };
        row2.appendChild(upBtn); row2.appendChild(downBtn); row2.appendChild(delBtn);

        actions.appendChild(row1); actions.appendChild(row2);

        frameDiv.appendChild(left);
        frameDiv.appendChild(actions);

        enableDragOnFrame(frameDiv, idx);
        frameListElem.appendChild(frameDiv);
      });
      frameCountElem.textContent = `${timeline.length} frame${timeline.length === 1 ? '' : 's'}`;
      updatePlayerStateDisplay();
    }

    /* timeline operations */
    function removeFrame(idx) { if (idx < 0 || idx >= timeline.length) return; timeline.splice(idx, 1); renderTimeline(); }
    function moveFrameUp(idx) { if (idx <= 0) return; const tmp = timeline[idx - 1]; timeline[idx - 1] = timeline[idx]; timeline[idx] = tmp; renderTimeline(); }
    function moveFrameDown(idx) { if (idx >= timeline.length - 1) return; const tmp = timeline[idx + 1]; timeline[idx + 1] = timeline[idx]; timeline[idx] = tmp; renderTimeline(); }
    function renameFrame(idx) { const newName = prompt('Rename frame', timeline[idx].name); if (newName !== null) { timeline[idx].name = newName.trim() || timeline[idx].name; renderTimeline(); pushHistory('rename'); } }
    function clearTimeline() { if (!confirm('Clear all frames from timeline?')) return; timeline = []; renderTimeline(); pushHistory('clear timeline'); }
    function duplicateSelected() {
      if (timeline.length === 0) return;
      const last = timeline[timeline.length - 1];
      const copy = {
        name: last.name + ' copy',
        hex: last.hex ? [...last.hex] : new Array(8).fill('00'),
        bits: last.bits ? [...last.bits] : new Array(64).fill(false),
        colors: last.colors ? [...last.colors] : new Array(64).fill(null)
      };
      timeline.push(copy);
      renderTimeline();
      pushHistory('duplicate frame');
    }

    /* preview modal */
    const overlay = document.getElementById('overlay');
    const previewGrid = document.getElementById('previewGrid');
    const previewTitle = document.getElementById('previewTitle');
    const previewHex = document.getElementById('previewHex');
    let previewIndex = -1;

    function openPreview(idx) {
      const f = timeline[idx]; if (!f) return;
      previewIndex = idx;
      previewTitle.textContent = `Preview: ${f.name}`;
      previewHex.textContent = f.hex ? f.hex.join(' ') : '';
      previewGrid.innerHTML = '';
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          const bitIndex = col * 8 + row;
          if (f.bits && f.bits[bitIndex]) cell.classList.add('on');
          if (f.colors && f.colors[bitIndex]) cell.style.backgroundColor = f.colors[bitIndex];
          previewGrid.appendChild(cell);
        }
      }
      overlay.classList.add('show');
    }
    function closePreview() { overlay.classList.remove('show'); previewIndex = -1; }
    function applyPreviewToGrid() { if (previewIndex < 0) return; applyFrame(previewIndex); closePreview(); }

    /* --- Player / controls --- */
    const speedRange = document.getElementById('speedRange');
    const speedLabel = document.getElementById('speedLabel');
    const playBtn = document.getElementById('playBtn');
    const loopToggle = document.getElementById('loopToggle');
    const currentFrameIndexLabel = document.getElementById('currentFrameIndex');

    function switchTab(tab) {
      document.getElementById('framesTab').style.display = tab === 'frames' ? 'block' : 'none';
      document.getElementById('playerTab').style.display = tab === 'player' ? 'block' : 'none';
      document.getElementById('tabFrames').classList.toggle('active', tab === 'frames');
      document.getElementById('tabPlayer').classList.toggle('active', tab === 'player');
    }
    function togglePlay() { if (playing) stopTimeline(); else startTimeline(); }
    function startTimeline() { if (timeline.length === 0) { alert('Timeline is empty. Add frames first.'); return; } playing = true; playBtn.textContent = 'Pause'; if (playIndex >= timeline.length) playIndex = 0; playStep(); }
    function stopTimeline() { playing = false; playBtn.textContent = 'Play'; if (playTimer) { clearTimeout(playTimer); playTimer = null; } currentFrameIndexLabel.textContent = '-'; playIndex = 0; }
    function playStep() {
      if (!playing) return;
      if (playIndex >= timeline.length) {
        if (loopToggle.checked) playIndex = 0;
        else { stopTimeline(); return; }
      }
      applyFrame(playIndex);
      currentFrameIndexLabel.textContent = (playIndex + 1) + '/' + timeline.length;
      const delay = parseInt(speedRange.value, 10);
      playIndex++;
      playTimer = setTimeout(playStep, delay);
    }
    function speedChanged() { speedLabel.textContent = speedRange.value; }
    function updatePlayerStateDisplay() { speedLabel.textContent = speedRange.value; currentFrameIndexLabel.textContent = timeline.length ? `- / ${timeline.length}` : '-'; }
    function stepForward() { if (timeline.length === 0) return; playIndex = (playIndex < timeline.length - 1) ? playIndex + 1 : (loopToggle.checked ? 0 : playIndex); applyFrame(playIndex); currentFrameIndexLabel.textContent = (playIndex + 1) + '/' + timeline.length; }
    function stepBackward() { if (timeline.length === 0) return; playIndex = (playIndex > 0) ? playIndex - 1 : (loopToggle.checked ? timeline.length - 1 : 0); applyFrame(playIndex); currentFrameIndexLabel.textContent = (playIndex + 1) + '/' + timeline.length; }

    /* --- Persistence, import/export --- */
    const STORAGE_KEY = 'microkit_timeline_v1';
    function saveTimelineToLocal() {
      try { const payload = JSON.stringify(timeline); localStorage.setItem(STORAGE_KEY, payload); console.info('Timeline saved to localStorage'); alert('Successfully saved to timeline locally'); }
      catch (e) { console.error('Save failed', e); alert('Failed to save timeline locally'); }
    }
    function loadTimelineFromLocal() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) { alert('No saved timeline found in local storage'); return; }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) throw new Error('Invalid format');
        timeline = parsed.map(f => normalizeFrame(f));
        renderTimeline();
        updatePlayerStateDisplay();
        pushHistory('load timeline');
        alert('Timeline loaded from local storage');
      } catch (e) { console.error('Load failed', e); alert('Failed to load timeline from local storage'); }
    }

    function exportTimelineJSON() {
      try {
        const payload = JSON.stringify(timeline, null, 2);
        const blob = new Blob([payload], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `microkit_timeline_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (e) { console.error('Export failed', e); alert('Failed to export timeline'); }
    }

    function importTimelineFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        try {
          const data = JSON.parse(ev.target.result);
          if (!Array.isArray(data)) throw new Error('Invalid format: expected array of frames');
          for (const f of data) {
            if (typeof f.name !== 'string') throw new Error('Invalid frame: missing name');
            if (!Array.isArray(f.hex) || f.hex.length !== 8) throw new Error('Invalid frame: hex must be array[8]');
            if (!Array.isArray(f.bits) || f.bits.length !== 64) throw new Error('Invalid frame: bits must be array[64]');
          }
          timeline = data.map(f => normalizeFrame(f));
          renderTimeline();
          updatePlayerStateDisplay();
          pushHistory('import timeline');
          alert('Timeline imported successfully');
        } catch (err) { console.error('Import error', err); alert('Failed to import file: ' + err.message); }
      };
      reader.onerror = () => { alert('Error reading file'); };
      reader.readAsText(file);
    }

    /* --- Keyboard shortcuts for undo/redo --- */
    window.addEventListener('keydown', (e) => {
      const isMac = /Mac|iPhone|iPad/.test(navigator.platform);
      const mod = isMac ? e.metaKey : e.ctrlKey;
      if (mod && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
      } else if (mod && (e.key.toLowerCase() === 'y')) {
        e.preventDefault();
        redo();
      }
    });

    /* --- Wire UI --- */
    document.getElementById('saveLocalBtn').addEventListener('click', saveTimelineToLocal);
    document.getElementById('loadLocalBtn').addEventListener('click', loadTimelineFromLocal);
    document.getElementById('exportBtn').addEventListener('click', exportTimelineJSON);
    document.getElementById('importFile').addEventListener('change', (e) => { const f = e.target.files && e.target.files[0]; if (f) importTimelineFile(f); e.target.value = ''; });

    /* --- Init --- */
    function start() {
      createGrid();
      createHexInputs();
      populateFillSelect();
      updateHex();
      restoreSavedTheme();
      const themeToggle = document.getElementById('toggle');
      if (themeToggle) themeToggle.checked = document.body.classList.contains('dark-mode');
      // initial history snapshot
      pushHistory('initial');
    }
    start();
    renderTimeline();
    updatePlayerStateDisplay();

    overlay.addEventListener('click', (ev) => { if (ev.target === overlay) closePreview(); });
    window._timeline = timeline;

    function populateFillSelect() {
      const sel = document.getElementById('fillColorSelect');
      if (!sel) return;
      sel.innerHTML = '';
      const namedColors = [
        { name: 'Off', hex: '' },
        { name: 'Green', hex: '#489e73' },
        { name: 'Red', hex: '#e94f4f' },
        { name: 'Orange', hex: '#f4a300' },
        { name: 'Yellow', hex: '#f7e13d' }
      ];
      for (const c of namedColors) {
        const opt = document.createElement('option');
        opt.value = c.hex;
        opt.textContent = c.name;
        sel.appendChild(opt);
      }
    }

    /* --- Theme helpers --- */
    function setThemeIcon(isDark) {
      const icon = document.getElementById('themeIcon');
      const btn = document.getElementById('themeBtn');
      if (!icon || !btn) return;
      icon.textContent = isDark ? '\ud83c\udf19' : '\u2600\ufe0f';
      btn.setAttribute('aria-pressed', isDark ? 'true' : 'false');
    }
    function toggleThemeAndSaveWithIcon() {
      const isDark = document.body.classList.toggle('dark-mode');
      const chosen = isDark ? 'dark' : 'light';
      try { localStorage.setItem(THEME_KEY, chosen); } catch (e) { }
      const themeToggle = document.getElementById('toggle');
      if (themeToggle) themeToggle.checked = isDark;
      setThemeIcon(isDark);
    }
    function applyThemeWithIcon(name) {
      if (name === 'dark') document.body.classList.add('dark-mode'); else document.body.classList.remove('dark-mode');
      document.documentElement.setAttribute('data-theme', name);
      const isDark = document.body.classList.contains('dark-mode');
      const themeToggle = document.getElementById('toggle');
      if (themeToggle) { try { themeToggle.checked = isDark; } catch { } }
      setThemeIcon(isDark);
    }
    function restoreSavedTheme() {
      try {
        const saved = localStorage.getItem(THEME_KEY);
        if (saved === 'dark' || saved === 'light') { applyThemeWithIcon(saved); return; }
      } catch (e) { }
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) applyThemeWithIcon('dark'); else applyThemeWithIcon('light');
    }
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('themeBtn');
      if (btn) btn.addEventListener('click', (e) => { e.preventDefault(); toggleThemeAndSaveWithIcon(); });
      setThemeIcon(document.body.classList.contains('dark-mode'));
    });

    /* --- Add / Overwrite frame helper kept for convenience --- */
    function addOrOverwriteFrame() {
      const nameInput = document.getElementById('frameName');
      const name = (nameInput.value || `Frame ${timeline.length + 1}`).trim();
      const captured = captureCurrentFrame();
      const idx = timeline.findIndex(f => f.name === name);
      const frameObj = { name, hex: captured.hexes, bits: captured.bits, colors: captured.colors };
      if (idx >= 0) timeline[idx] = frameObj;
      else timeline.push(frameObj);
      nameInput.value = '';
      hideAddFrame();
      renderTimeline();
      pushHistory('add/overwrite frame');
    }

    /* --- Compatibility small theme helpers (kept) --- */
    function applyTheme(name) { if (name === 'dark') document.body.classList.add('dark-mode'); else document.body.classList.remove('dark-mode'); document.documentElement.setAttribute('data-theme', name); }
    function toggleThemeAndSave() { const isDark = document.body.classList.toggle('dark-mode'); try { localStorage.setItem('microkit_theme_v1', isDark ? 'dark' : 'light'); } catch (e) { } const themeToggle = document.getElementById('toggle'); if (themeToggle) themeToggle.checked = isDark; }

    /* --- Jump/Loop offset calculator (fixed for long offsets) --- */
    /*
      Behavior:
      - Parse current and target as hex (supports 0x prefix or plain hex).
      - Compute relative offset = target - current - instruction_length.
        (existing UI used -2; we preserve that for the same instruction length)
      - If offset fits signed 8-bit (-128..127) show short offset (one byte).
      - Otherwise compute signed 16-bit offset and show two-byte little-endian hex for longer relative jumps.
      - Display signed decimal and hex bytes so you can plug into assembler/data as needed.
    */
    function calculateJump() {
      const currentRaw = document.getElementById('current').value.trim();
      const targetRaw = document.getElementById('target').value.trim();
      // accept 0x... or plain hex
      const parseHex = s => {
        if (!s) return NaN;
        const cleaned = ('' + s).trim().toUpperCase().replace(/^0X/, '');
        if (!/^[0-9A-F]+$/.test(cleaned)) return NaN;
        return parseInt(cleaned, 16);
      };
      const current = parseHex(currentRaw);
      const target = parseHex(targetRaw);
      const result = document.getElementById('result');
      if (isNaN(current) || isNaN(target)) {
        result.textContent = "Invalid hex input. Use values like 1000 or 100D or 0x1000.";
        return;
      }

      // Instruction length assumed to be 2 bytes like original (preserve prior behavior)
      const instrLen = 2;
      const rel = target - current - instrLen;

      // Helper to format signed numbers and bytes
      const toSigned = (v, bits) => {
        const max = 1 << bits;
        const signed = (v & (max - 1)) < (1 << (bits - 1)) ? (v & (max - 1)) : (v & (max - 1)) - max;
        return signed;
      };
      const toHexByte = (v) => (v & 0xFF).toString(16).padStart(2, '0').toUpperCase();
      const toHexWordLE = (v) => {
        const val = v & 0xFFFF;
        const lo = val & 0xFF;
        const hi = (val >> 8) & 0xFF;
        return [toHexByte(lo), toHexByte(hi)];
      };

      // short (signed 8-bit) range
      if (rel >= -128 && rel <= 127) {
        const signed8 = toSigned(rel, 8);
        const hexByte = toHexByte(signed8);
        result.textContent = `Short jump: value = ${hexByte}`;
        return;
      }

      // signed 16-bit
      if (rel >= -32768 && rel <= 32767) {
        const signed16 = toSigned(rel, 16);
        const [lo, hi] = toHexWordLE(signed16);
        result.textContent = `Long relative jump: value = ${lo} ${hi}`;
        return;
      }

      // absolute difference too large for signed 16-bit relative
      const dec = rel;
      const absHex = (Math.abs(dec)).toString(16).toUpperCase();
      result.textContent = `Offset ${dec} out of range for 16-bit relative. Consider using absolute jump or trampoline sequence. (${absHex})`;
    }

    /* --- Theme key used by helpers above --- */
    const THEME_KEY = 'microkit_theme_v1';

    /* --- Expose small helpers for debug --- */
    window._timeline = timeline;
  </script>


</body>

</html>
